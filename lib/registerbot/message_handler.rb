require 'telegram/bot'
require 'sequel'

# The class handling all messages received by the user.
class Message_handler

    # Creates a new `Registerbot` instance. Uses the Database given to create two seperate tables for reports and feedback. 
    #   Creates one instance of each `Reports_processor`, `Helper_processor` and `Feedback_processor` to process incoming messages of each type.
    #
    # @param bot [Telegram::Bot::Client] the actual bot communicating with the telegram bot-API
    # @param bot_token [String] a bot token generated by the Telegram Bot Father to identify the correct Bot to control
    # @param db [Sequel::Database] a Database used to store all reports and feedback
    # @param image_path [String] a path to a folder in which we will store all images send along the reports
    def initialize(bot, db, image_path, bot_token, logger)
        
        # Create Tables
        #
        # @param id [primary_key] stores the unique id for each report, beginning by 1
        # @param date [String] stores the date for a report given by the user, note that this is not a Time, because users can enter inconcrete dates
        # @param place [String] stores the place for a report given by the user
        # @param activity [String] stores the observed act described by the user
        # @param contact [String] stores any sort of contact (E-Mail / Telephone / other) if given by the user
        # @param image_path [String] stores the file_id of an image on the Telegram servers, also duplicates as the file name for downloaded files to identify them later on
        # @param timestamp [Float] stores the `Time` of the report when recorded by the bot in Float format, later used to identify the most recent messages
        unless db.table_exists?(:reports)
            db.create_table :reports do
                primary_key :id 
                String :date
                String :place
                String :activity
                Float :timestamp
                String :contact
                String :image_path
            end
        end
        unless db.table_exists?(:feedback)
            db.create_table :feedback do
                primary_key :id
                String :rating
                String :tips
            end
        end
        reports = db[:reports]
        feedback = db[:feedback]

        download_url = "https://api.telegram.org/file/bot#{bot_token}"
        @reports_processor = Reports_processor.new(bot, reports, image_path, download_url, logger)
        @feedback_processor = Feedback_processor.new(bot, feedback, logger)
        @help_processor = Help_processor.new(bot, logger)
        @logger = logger
    end

    # Handles the received message and directs it to the corresponding processor
    #
    # @param message [Telegram::Bot::Types::Message] the messaged received from the user
    def handle_message(message)
        
        # Identify whether the message has a text (as in normal text messages) or a caption (as in phot, video or file messages) or neither.
        #   This is necessary as the user cannot choose which one to use, so we just have to see which one is given.
        #   If non is given, we use an empty `String` instead of nil, so that we can still call the `String#split` Method without causing Errors.
        text = ""
        if message.text != nil
            text = message.text
        elsif message.caption != nil
            text = message.caption
        end

        # Split the Text on each ' ', because we need to identify the first Word.
        #   This is necessary as sometimes the first word is a command and sometimes it is not.
        #   Also some processor methods require exactly the first word of the message.
        args = text.split(' ')

        # Get the chat id because I am too lazy to type this phrase 4 times in the next 5 lines
        id = message.chat.id

        # The user_state is the state of a user inside a conversation with the Bot. 
        #   These conversations only happen at two points: When giving Feedback or when reporting an activity vie the formular report. 
        #   Thus we need to check both processors whether the user is already in a conversation and delegate the message to the corresponding answering method.
        #   if none of them is set, we can just use nil as the value, as we do not need to call methds on this object.
        user_state = nil
        if @feedback_processor.user_state[id] != nil
            user_state = @feedback_processor.user_state[id].state
        elsif @reports_processor.user_state[id] != nil
                user_state = @reports_processor.user_state[id].state
        end

        # Check the user_state of the processors to find the corresponding answering method
        #   See the meaning of each `user_state` above
        case user_state
        when RATING
            @feedback_processor.get_rating(args[0], message)
        when ASKED_FOR_TIPS
            @feedback_processor.get_feedback_decision(args[0], message)
        when GIVING_TIPS
            @feedback_processor.get_tips(message)
        when REPORTING_DATE
            @reports_processor.get_report_date(args, message)
        when REPORTING_PLACE
            @reports_processor.get_report_place(args, message)
        when REPORTING_ACTIVITY
            @reports_processor.get_report_activity(args, message)
        when ASKED_FOR_CONTACTS
            @reports_processor.get_contact_decision(args[0], message)
        when GIVING_CONTACTS
            @reports_processor.get_contact(args, message)
        when ASKED_FOR_IMAGE
            @reports_processor.get_image_decision(args[0], message)
        when GIVING_IMAGE
            @reports_processor.get_image(args, message)
        else
            # If the user currently is in no specific `user_state`, they either sent a command which we need to identify, or we need to tell them we don't understand them
            #   Commands are defined in 'commands.rb'
            case args[0]
            when START 
                @help_processor.start(message)
            when HELP 
                @help_processor.help(message)
            when REPORT 
                @reports_processor.report(args, message)
            when FORMULAR_REPORT
                @reports_processor.form_report(message)
            when COUNT 
                @reports_processor.count(message)
            when ALL 
                @reports_processor.all(message)
            when LAST 
                @reports_processor.last(args, message)
            when FEEDBACK
                @feedback_processor.feedback(message)
            when ALL_FEEDBACK
                @feedback_processor.all_feedback(message)
            when INSPECT
                @reports_processor.inspect(args, message)
            else
                @help_processor.unknown(message)
            end
        end
    end
end